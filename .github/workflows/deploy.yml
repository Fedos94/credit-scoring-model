name: CI/CD Pipeline (Build → Test → Deploy)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: cr.yandex
  IMAGE_NAME: credit-scoring-api
  REGISTRY_ID: "crpn72dh0c06a6o5php2"  # Ваш ID реестра
  K8S_NAMESPACE_STAGING: "credit-scoring-staging"
  K8S_NAMESPACE_PROD: "credit-scoring"

jobs:
  build-and-test:
    name: "Build & Test"
    runs-on: ubuntu-latest
    
    outputs:
      image-tag: ${{ steps.build.outputs.sha-tag }}
      image-name: ${{ steps.build.outputs.image-name }}
    
    steps:
      - name: "Checkout Code"
        uses: actions/checkout@v4

      - name: "Set up Docker Buildx"
        uses: docker/setup-buildx-action@v3

      - name: "Log in to Yandex Container Registry"
        uses: yc-actions/yc-cr-login@v3
        with:
          yc-sa-json-credentials: ${{ secrets.YC_SA_KEY }}

      - name: "Build and Push Docker Image"
        id: build
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
          IMAGE_TAG=${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:sha-$SHORT_SHA
          
          echo "Building image: $IMAGE_TAG"
          docker build -t $IMAGE_TAG .
          docker push $IMAGE_TAG
          
          # Сохраняем тег в файл для передачи между jobs
          echo "$IMAGE_TAG" > image-tag.txt
          
          # Сохраняем outputs
          echo "sha-tag=sha-$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "image-name=${{ env.IMAGE_NAME }}" >> $GITHUB_OUTPUT

      - name: "Upload image tag as artifact"
        uses: actions/upload-artifact@v4
        with:
          name: image-tag
          path: image-tag.txt
          retention-days: 1

      - name: "Install dependencies and run tests"
        run: |
          pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
          if [ -d tests ]; then
            python -m pytest tests/ -v --tb=short --junitxml=test-results.xml
          else
            echo "No tests directory found"
          fi

      - name: "Upload test results"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: test-results.xml

  security-scan:
    name: "Security Scan"
    runs-on: ubuntu-latest
    needs: [build-and-test]
    permissions:
      security-events: write
      contents: read
      id-token: write
    
    steps:
      - name: "Download image tag"
        uses: actions/download-artifact@v4
        with:
          name: image-tag
      
      - name: "Load image tag"
        run: |
          IMAGE_TAG=$(cat image-tag.txt)
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "Image tag loaded: $IMAGE_TAG"
      
      - name: "Login to Yandex Container Registry"
        run: |
          echo '${{ secrets.YC_SA_KEY }}' | docker login \
            --username json_key \
            --password-stdin \
            cr.yandex
      
      - name: "Pull Docker image for scanning"
        run: |
          echo "Pulling image: $IMAGE_TAG"
          docker pull $IMAGE_TAG || echo "Warning: Could not pull image, but continuing..."
      
      - name: "Run Trivy vulnerability scanner"
        if: env.IMAGE_TAG != ''
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
      
      - name: "Upload Vulnerability Report"
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: "Check for Secrets in Code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: "Install and run detect-secrets"
        run: |
          pip install detect-secrets
          # Создаем baseline если не существует
          if [ ! -f .secrets.baseline ]; then
            detect-secrets scan > .secrets.baseline
          fi
          detect-secrets scan --baseline .secrets.baseline || echo "Secrets check completed"

  deploy-staging:
    name: "Deploy to Staging"
    runs-on: ubuntu-latest
    needs: [build-and-test]
    environment: 
      name: staging
      url: https://staging.credit-scoring.your-domain.com
    permissions:
      contents: read
      deployments: write
    
    steps:
      - name: "Download image tag"
        uses: actions/download-artifact@v4
        with:
          name: image-tag
      
      - name: "Load image tag"
        id: load-tag
        run: |
          IMAGE_TAG=$(cat image-tag.txt)
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "Using image: $IMAGE_TAG"
      
      - name: "Checkout Code"
        uses: actions/checkout@v4
      
      - name: "Configure kubeconfig for Yandex Cloud"
        run: |
          # Создаем директорию .kube
          mkdir -p $HOME/.kube
          
          # Сохраняем kubeconfig
          echo "Decoding kubeconfig from secret..."
          KUBECONFIG_CONTENT=$(echo '${{ secrets.YC_KUBECONFIG }}' | base64 --decode)
          echo "$KUBECONFIG_CONTENT" > $HOME/.kube/config
          
          # Проверяем содержимое kubeconfig (безопасно, без секретов)
          echo "=== Kubeconfig structure ==="
          kubectl config view --minify --raw | grep -E "^(apiVersion|clusters|contexts|current-context):" || true
          
          # Пытаемся автоматически установить контекст
          CURRENT_CONTEXT=$(kubectl config view -o jsonpath='{.current-context}' 2>/dev/null || true)
          
          if [ -z "$CURRENT_CONTEXT" ]; then
            echo "WARNING: No current context set. Trying to set one..."
            
            # Получаем список контекстов
            CONTEXTS=$(kubectl config get-contexts -o name 2>/dev/null || true)
            
            if [ -n "$CONTEXTS" ]; then
              # Берем первый контекст из списка
              FIRST_CONTEXT=$(echo "$CONTEXTS" | head -1)
              echo "Setting context to: $FIRST_CONTEXT"
              kubectl config use-context "$FIRST_CONTEXT"
            else
              echo "ERROR: No contexts found in kubeconfig!"
              echo "Kubeconfig content (first 10 lines):"
              head -10 $HOME/.kube/config
              exit 1
            fi
          else
            echo "Current context: $CURRENT_CONTEXT"
          fi
          
          # Проверяем доступ к кластеру
          echo "Testing cluster connection..."
          kubectl cluster-info || echo "WARNING: Could not connect to cluster"
          
          # Проверяем ноды
          kubectl get nodes --request-timeout=10s || echo "WARNING: Could not get nodes"
      
      - name: "Verify Kubernetes access"
        run: |
          kubectl cluster-info
          kubectl get nodes
      
      - name: "Deploy to Kubernetes (Staging)"
        run: |
          # Создаем namespace если не существует
          kubectl create namespace ${{ env.K8S_NAMESPACE_STAGING }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Проверяем существование файла манифеста
          if [ ! -f k8s/staging.yaml ]; then
            echo "ERROR: k8s/staging.yaml not found!"
            exit 1
          fi
          
          # Применяем манифест
          kubectl apply -f k8s/staging.yaml -n ${{ env.K8S_NAMESPACE_STAGING }}
          
          # Обновляем образ в deployment
          kubectl set image deployment/credit-scoring-api \
            api=$IMAGE_TAG \
            -n ${{ env.K8S_NAMESPACE_STAGING }}
      
      - name: "Wait for rollout to complete"
        run: |
          kubectl rollout status deployment/credit-scoring-api \
            -n ${{ env.K8S_NAMESPACE_STAGING }} \
            --timeout=180s
      
      - name: "Verify service is accessible"
        run: |
          # Ждем немного перед проверкой
          sleep 15
          kubectl get pods -n ${{ env.K8S_NAMESPACE_STAGING }}
          kubectl get svc -n ${{ env.K8S_NAMESPACE_STAGING }}

  deploy-production:
    name: "Deploy to Production"
    runs-on: ubuntu-latest
    needs: [deploy-staging, security-scan]
    environment: 
      name: production
      url: https://credit-scoring.your-domain.com
    permissions:
      contents: read
      deployments: write
    
    steps:
      - name: "Download image tag"
        uses: actions/download-artifact@v4
        with:
          name: image-tag
      
      - name: "Load image tag"
        id: load-tag
        run: |
          IMAGE_TAG=$(cat image-tag.txt)
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
      
      - name: "Checkout Code"
        uses: actions/checkout@v4
      
      - name: "Configure kubeconfig for Yandex Cloud"
        run: |
          mkdir -p $HOME/.kube
          echo '${{ secrets.YC_KUBECONFIG }}' | base64 --decode > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl config current-context
      
      - name: "Verify Kubernetes access"
        run: |
          kubectl cluster-info
          kubectl get nodes
      
      - name: "Deploy to Kubernetes (Production)"
        run: |
          # Обновляем образ в deployment
          kubectl set image deployment/credit-scoring-api \
            api=$IMAGE_TAG \
            -n ${{ env.K8S_NAMESPACE_PROD }}
      
      - name: "Wait for rollout to complete"
        run: |
          kubectl rollout status deployment/credit-scoring-api \
            -n ${{ env.K8S_NAMESPACE_PROD }} \
            --timeout=180s
      
      - name: "Verify production deployment"
        run: |
          sleep 10
          kubectl get pods -n ${{ env.K8S_NAMESPACE_PROD }}
          echo "Production deployment successful!"