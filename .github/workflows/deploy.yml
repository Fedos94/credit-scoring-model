name: CI/CD Pipeline (Build → Test → Deploy)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: cr.yandex
  IMAGE_NAME: credit-scoring-api
  REGISTRY_ID: "crpn72dh0c06a6o5php2"  # Ваш ID реестра
  K8S_NAMESPACE_STAGING: "credit-scoring-staging"
  K8S_NAMESPACE_PROD: "credit-scoring"

jobs:
  build-and-test:
    name: "Build & Test"
    runs-on: ubuntu-latest
    
    outputs:
      image-tag: ${{ steps.build.outputs.sha-tag }}
      image-name: ${{ steps.build.outputs.image-name }}
    
    steps:
      - name: "Checkout Code"
        uses: actions/checkout@v4

      - name: "Set up Docker Buildx"
        uses: docker/setup-buildx-action@v3

      - name: "Log in to Yandex Container Registry"
        uses: yc-actions/yc-cr-login@v3
        with:
          yc-sa-json-credentials: ${{ secrets.YC_SA_KEY }}

      - name: "Build and Push Docker Image"
        id: build
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
          IMAGE_TAG=${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:sha-$SHORT_SHA
          
          echo "Building image: $IMAGE_TAG"
          docker build -t $IMAGE_TAG .
          docker push $IMAGE_TAG
          
          # Сохраняем тег в файл для передачи между jobs
          echo "$IMAGE_TAG" > image-tag.txt
          
          # Сохраняем outputs
          echo "sha-tag=sha-$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "image-name=${{ env.IMAGE_NAME }}" >> $GITHUB_OUTPUT

      - name: "Upload image tag as artifact"
        uses: actions/upload-artifact@v4
        with:
          name: image-tag
          path: image-tag.txt
          retention-days: 1

      - name: "Install dependencies and run tests"
        run: |
          pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
          if [ -d tests ]; then
            python -m pytest tests/ -v --tb=short --junitxml=test-results.xml
          else
            echo "No tests directory found"
          fi

      - name: "Upload test results"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: test-results.xml

  security-scan:
    name: "Security Scan"
    runs-on: ubuntu-latest
    needs: [build-and-test]
    permissions:
      security-events: write
      contents: read
      id-token: write
    
    steps:
      - name: "Download image tag"
        uses: actions/download-artifact@v4
        with:
          name: image-tag
      
      - name: "Load image tag"
        run: |
          IMAGE_TAG=$(cat image-tag.txt)
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "Image tag loaded: $IMAGE_TAG"
      
      - name: "Login to Yandex Container Registry"
        run: |
          echo '${{ secrets.YC_SA_KEY }}' | docker login \
            --username json_key \
            --password-stdin \
            cr.yandex
      
      - name: "Pull Docker image for scanning"
        run: |
          echo "Pulling image: $IMAGE_TAG"
          docker pull $IMAGE_TAG || echo "Warning: Could not pull image, but continuing..."
      
      - name: "Run Trivy vulnerability scanner"
        if: env.IMAGE_TAG != ''
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
      
      - name: "Upload Vulnerability Report"
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: "Check for Secrets in Code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: "Install and run detect-secrets"
        run: |
          pip install detect-secrets
          # Создаем baseline если не существует
          if [ ! -f .secrets.baseline ]; then
            detect-secrets scan > .secrets.baseline
          fi
          detect-secrets scan --baseline .secrets.baseline || echo "Secrets check completed"

  deploy-staging:
    name: "Deploy to Staging"
    runs-on: ubuntu-latest
    needs: [build-and-test]
    environment: 
      name: staging
      url: https://staging.credit-scoring.your-domain.com
    permissions:
      contents: read
      deployments: write
    
    steps:
      - name: "Download image tag"
        uses: actions/download-artifact@v4
        with:
          name: image-tag
      
      - name: "Load image tag"
        id: load-tag
        run: |
          IMAGE_TAG=$(cat image-tag.txt)
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "Using image: $IMAGE_TAG"
      
      - name: "Checkout Code"
        uses: actions/checkout@v4
      
      - name: "Configure Yandex Cloud CLI"
        uses: yc-actions/yc-cr-login@v3
        with:
          yc-sa-json-credentials: ${{ secrets.YC_SA_KEY }}

      - name: "Install Yandex Cloud CLI"
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
          source ~/.bashrc
          yc version

      - name: "Get kubeconfig for cluster"
        run: |
          # Установите имя вашего кластера
          CLUSTER_NAME="your-cluster-name"
          
          # Получаем kubeconfig
          yc managed-kubernetes cluster get-credentials $CLUSTER_NAME --external --force
          
          # Проверяем
          kubectl config current-context
          kubectl get nodes
      
      - name: "Verify Kubernetes access"
        run: |
          kubectl cluster-info
          kubectl get nodes
      
      - name: "Deploy to Kubernetes (Staging)"
        run: |
          # Создаем namespace если не существует
          kubectl create namespace ${{ env.K8S_NAMESPACE_STAGING }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Проверяем существование файла манифеста
          if [ ! -f k8s/staging.yaml ]; then
            echo "ERROR: k8s/staging.yaml not found!"
            exit 1
          fi
          
          # Применяем манифест
          kubectl apply -f k8s/staging.yaml -n ${{ env.K8S_NAMESPACE_STAGING }}
          
          # Обновляем образ в deployment
          kubectl set image deployment/credit-scoring-api \
            api=$IMAGE_TAG \
            -n ${{ env.K8S_NAMESPACE_STAGING }}
      
      - name: "Wait for rollout to complete"
        run: |
          kubectl rollout status deployment/credit-scoring-api \
            -n ${{ env.K8S_NAMESPACE_STAGING }} \
            --timeout=180s
      
      - name: "Verify service is accessible"
        run: |
          # Ждем немного перед проверкой
          sleep 15
          kubectl get pods -n ${{ env.K8S_NAMESPACE_STAGING }}
          kubectl get svc -n ${{ env.K8S_NAMESPACE_STAGING }}

  deploy-production:
    name: "Deploy to Production"
    runs-on: ubuntu-latest
    needs: [deploy-staging, security-scan]
    environment: 
      name: production
      url: https://credit-scoring.your-domain.com
    permissions:
      contents: read
      deployments: write
    
    steps:
      - name: "Download image tag"
        uses: actions/download-artifact@v4
        with:
          name: image-tag
      
      - name: "Load image tag"
        id: load-tag
        run: |
          IMAGE_TAG=$(cat image-tag.txt)
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
      
      - name: "Checkout Code"
        uses: actions/checkout@v4
      
      - name: "Configure kubeconfig for Yandex Cloud"
        run: |
          mkdir -p $HOME/.kube
          echo '${{ secrets.YC_KUBECONFIG }}' | base64 --decode > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl config current-context
      
      - name: "Verify Kubernetes access"
        run: |
          kubectl cluster-info
          kubectl get nodes
      
      - name: "Deploy to Kubernetes (Production)"
        run: |
          # Обновляем образ в deployment
          kubectl set image deployment/credit-scoring-api \
            api=$IMAGE_TAG \
            -n ${{ env.K8S_NAMESPACE_PROD }}
      
      - name: "Wait for rollout to complete"
        run: |
          kubectl rollout status deployment/credit-scoring-api \
            -n ${{ env.K8S_NAMESPACE_PROD }} \
            --timeout=180s
      
      - name: "Verify production deployment"
        run: |
          sleep 10
          kubectl get pods -n ${{ env.K8S_NAMESPACE_PROD }}
          echo "Production deployment successful!"